package darts.lib.sql.jdbc

import java.sql.ResultSet

sealed trait Column[T] {

    def descriptor: Type[T]

    def apply(rs: ResultSet): Option[T]

    def required = new NotNullReader(this, (_: Option[T]).get)

    def forced(fn: Option[T] => T) = new NotNullReader(this, fn)

    def defaultsTo(value: T) = new NotNullReader(this, (_: Option[T]).getOrElse(value))
}

final case class IndexedColumn[T](val index: Int, val descriptor: Type[T]) extends Column[T] {
    def apply(rs: ResultSet): Option[T] = descriptor.readValue(rs, index)
}

final case class NamedColumn[T](val name: String, val descriptor: Type[T]) extends Column[T] {
    def apply(rs: ResultSet): Option[T] = descriptor.readValue(rs, name)
}

final case class NotNullReader[T](val reader: Column[T], val forcer: (Option[T]) => T) {
    def descriptor: Type[T] = reader.descriptor

    def apply(rs: ResultSet): T = forcer(reader(rs))
}

object Column {

    def apply[T](name: String, desc: Type[T]): Column[T] = NamedColumn(name, desc)

    def apply[T](index: Int, desc: Type[T]): Column[T] = IndexedColumn(index, desc)
}

/**
  * Typed wrapper around a JDBC result set. Right now, only
  * forward traversal is implemented
  */

trait Cursor[+T] {

    /**
      * Advance the cursor.
      *
      * @return true, if the cursor has been moved to the next
      *         available record, and false, if there are no more
      *         records.
      */

    def next: Boolean

    /**
      * Obtain the current record. The effect of calling this method
      * is undefined, if the call is not preceded by a call to `next`
      * which did return true, or if the last call to `next` did not
      * return true.
      *
      * @return the record currently selected
      */

    def get: T

    /**
      * Converts this cursor into a stream. Note, that the stream
      * returned consumes the cursor; the caller should not use the
      * cursor instance itself after it has obtained a stream using
      * this method. Also note, that this method will always advance
      * the cursor in order to reach the first stream element.
      *
      * @return a stream, which yields the elements generated by
      *         this cursor
      */

    def toStream: Stream[T] =
    if (!next) Stream.empty else Stream.cons(get, toStream)

    /**
      * Converts this cursor into a stream. Note, that the stream
      * returned consumes the cursor; the caller should not use the
      * cursor instance itself after it has obtained a stream using
      * this method. If `fromHere`, the cursor is assumed to be
      * positioned on the first element to yield (and the stream
      * returned will never be the empty stream), otherwise, the
      * cursor is advanced to reach the first element.
      *
      * @return a stream, which yields the elements generated by
      *         this cursor
      */

    def toStream(fromHere: Boolean): Stream[T] =
    if (fromHere) get #:: toStream else toStream
}

abstract class BasicCursor[T](private val underlying: ResultSet) extends Cursor[T] {

    private var current: T = _
    private var available: Boolean = false

    protected def read(rs: ResultSet): T

    final def next: Boolean = {
        if (!underlying.next) {
            available = false
            false
        } else {
            current = read(underlying)
            available = true
            true
        }
    }

    final def get: T =
        if (!available) throw new IllegalStateException
        else current
}